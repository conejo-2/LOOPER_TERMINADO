<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Looper - Juego Mejorado</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000000;
            color: #eee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #gameArea {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
            background-color: #1a1a1a;
        }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 10;
        }
        #puntaje {
            font-size: 2em;
            font-weight: bold;
            color: #363636;
            text-shadow: 0 0 10px #363636;
        }
        #instructions {
            font-size: 1em;
            color: #363636;
        }
        .back-to-menu {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
        }
        .menu-button {
            padding: 10px 20px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 2px solid #363636;
            color: #363636;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s;
        }
        .menu-button:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }
        /* Tutorial overlays */
        .tutorial-overlay-backdrop {
            position: fixed;
            left: 0; top: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        .tutorial-box {
            background: #f5f5f5;
            color: #111;
            padding: 18px;
            border-radius: 12px;
            width: min(640px, 90%);
            box-shadow: 0 8px 30px rgba(0,0,0,0.6);
            text-align: center;
        }
        .tutorial-box h3 {
            margin: 0 0 8px 0;
        }
        .tutorial-demo {
            margin-top: 12px;
            width: 320px;
            height: 120px;
            background: #000;
            display: inline-block;
            border-radius: 8px;
            overflow: hidden;
        }
        .tutorial-cta {
            margin-top: 12px;
            padding: 10px 16px;
            background: #222;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            display: inline-block;
        }
    </style>
    <script>
        const usuario = new URLSearchParams(window.location.search).get('usuario');
        if (usuario) {
            localStorage.setItem('usuario_looper', usuario);
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js/dist/umd/supabase.min.js"></script>
    <script src="supabaseClient.js"></script>
    <script src="guardar_ranking.js"></script>
</head>
<body>
    <div id="gameArea"></div>
    <div id="ui-container">
        <div id="puntaje">Puntaje: 0</div>
        <div id="instructions">Mantén presionado para cerrar</div>
    </div>
    
    <a href="LOOPER_MENU.html" class="back-to-menu">
        <button class="menu-button">Volver al Menú</button>
    </a>

    <script>
        // --- MODO ---
        const params = new URLSearchParams(window.location.search);
        const modo = params.get('modo') || 'practica';

    // Tutorial state
    const tutorialMode = modo === 'tutorial';
    let tutorialPaused = false; // when true, game progression (time, obstacles) is paused
    let tutorialStage = 0; // 0 = intro pending, 1 = playing after intro, 2 = obstacle hint pending, 3 = playing after hint
    let tutorialFirstObstacleShown = false;

        // --- CONFIGURACIÓN ---
        const gameArea = document.getElementById('gameArea');
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        gameArea.appendChild(canvas);

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        const centerY = () => canvas.height / 2;

        // Serpiente
        const serpienteWidth = 18;
        const serpienteLength = 40;
        const startX = 70;
        const endX = startX + serpienteLength;

        // Obstáculos
        const obstaculoBaseSize = serpienteWidth * 2.2;
        const obstaculoBaseSpeed = 250; 
        const obstaculoBaseInterval = 1.8;

        const separationMin = 2;

        // --- ESTADO DEL JUEGO ---
        let puntaje = 0;
        let gameTime = 0;
        let obstaculos = [];
        let gameOver = false;
        let lastTime = 0;
        let gameHasStarted = false;

        let sepActual = separationMin;
        let sepObjetivo = separationMin;
        let isClosing = false;
        
        let targetDiagonalOffset = 0;
        let currentDiagonalOffset = 0;

        // --- CONTROLES ---
        function startGameOnce() {
            // If tutorial mode and still in intro stage (not even confirmed), don't start progression
            if (tutorialMode && tutorialStage === 0) return;
            // If in tutorial and intro was confirmed (stage 1), unpause progression on the first real interaction
            if (tutorialMode && tutorialStage === 1) {
                tutorialPaused = false; // allow game to progress
                // keep tutorialStage as 1 (playing after intro)
            }
            if (!gameHasStarted) {
                gameHasStarted = true;
                lastTime = performance.now();
            }
        }

    gameArea.addEventListener('mousedown', () => { startGameOnce(); isClosing = true; });
        gameArea.addEventListener('touchstart', e => { startGameOnce(); isClosing = true; e.preventDefault(); });
        gameArea.addEventListener('mouseup', () => isClosing = false);
        gameArea.addEventListener('mouseleave', () => isClosing = false);
        gameArea.addEventListener('touchend', () => isClosing = false);
        window.addEventListener('keydown', e => { if (e.code === 'Space') { startGameOnce(); isClosing = true; } });
        window.addEventListener('keyup', e => { if (e.code === 'Space') isClosing = false; });

        const puntajeDiv = document.getElementById('puntaje');

        function getDifficultyMultiplier() {
            return 1 + puntaje / 300;
        }
        
        // --- SERPIENTES ---
        function updateSerpientes(deltaTime) {
            const maxOpeningSpeed = 500 * deltaTime;
            const maxClosingSpeed = 700 * deltaTime;

            if (isClosing) {
                sepObjetivo -= maxClosingSpeed; 
            } else {
                sepObjetivo += maxOpeningSpeed;
            }

            sepObjetivo = Math.max(separationMin, sepObjetivo);
            
            const lerpFactor = 8;
            let previousSep = sepActual;
            sepActual += (sepObjetivo - sepActual) * lerpFactor * deltaTime;

            const movementSpeed = sepActual - previousSep;
            targetDiagonalOffset = movementSpeed * 2.5;
            targetDiagonalOffset = Math.max(-20, Math.min(targetDiagonalOffset, 20));
            
            const smoothingFactor = 12 * deltaTime;
            currentDiagonalOffset += (targetDiagonalOffset - currentDiagonalOffset) * smoothingFactor;
        }

        // Colores de serpientes desde localStorage o por defecto
        const defaultColors = {
            1: '#FF0000',  // Rojo por defecto serpiente 1
            2: '#0000FF'   // Azul por defecto serpiente 2
        };

        function getSnakeColors() {
            const savedColors = localStorage.getItem('snake_colors');
            if (!savedColors) return { 1: defaultColors[1], 2: defaultColors[2] };
            
            const colorIndices = JSON.parse(savedColors);
            const availableColors = [
                '#FF0000', // rojo
                '#0000FF', // azul
                '#FFFF00', // amarillo
                '#00FF00', // verde
                '#800080', // violeta
                '#00FFFF', // celeste
                '#FFFFFF', // blanco
                '#808080', // gris
                '#FFA500', // naranja
                '#FF69B4', // rosa
                '#40E0D0', // turquesa
                '#006400'  // verde oscuro
            ];
            const snakeColors = {
                1: availableColors,
                2: availableColors
            };
            
            return {
                1: snakeColors[1][colorIndices[1]] || defaultColors[1],
                2: snakeColors[2][colorIndices[2]] || defaultColors[2]
            };
        }

        function drawSerpientes() {
            ctx.save();
            const colors = getSnakeColors();
            
            const drawDiagonalSerpent = (y, color, shadowColor, direction) => {
                ctx.beginPath();
                const startPointY = y;
                const endPointY = y - currentDiagonalOffset * direction;
                ctx.moveTo(startX, startPointY);
                ctx.lineTo(endX, endPointY);

                ctx.strokeStyle = color;
                ctx.lineWidth = serpienteWidth;
                ctx.shadowColor = shadowColor;
                ctx.shadowBlur = 15;
                ctx.lineCap = "round";
                ctx.stroke();
            };

            const drawSpiral = () => {
                const rollTime = gameTime * 15;
                const rollSin = Math.sin(rollTime);
                const spiralFreq = 0.08; 
                const spiralAmp = serpienteWidth * 0.4;
                const frontWidth = serpienteWidth * 0.7;
                const backWidth = serpienteWidth * 0.55;

                const drawSpiralWave = (phase, color, width) => {
                    ctx.beginPath();
                    ctx.moveTo(startX, centerY() + Math.sin(startX * spiralFreq + rollTime + phase) * spiralAmp);
                    for (let x = startX + 5; x <= endX; x += 5) {
                        ctx.lineTo(x, centerY() + Math.sin(x * spiralFreq + rollTime + phase) * spiralAmp);
                    }
                    ctx.strokeStyle = color;
                    ctx.lineWidth = width;
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 12;
                    ctx.lineCap = "round";
                    ctx.stroke();
                };

                const colors = getSnakeColors();
                if (rollSin > 0) {
                    drawSpiralWave(Math.PI, colors[2], backWidth);
                    drawSpiralWave(0, colors[1], frontWidth);
                } else {
                    drawSpiralWave(0, colors[1], backWidth);
                    drawSpiralWave(Math.PI, colors[2], frontWidth);
                }
            };
            
            const transitionStart = separationMin;
            const transitionEnd = separationMin + 40;

            if (sepActual <= transitionStart) {
                drawSpiral();
            } else if (sepActual > transitionStart && sepActual < transitionEnd) {
                const progress = (sepActual - transitionStart) / (transitionEnd - transitionStart);
                ctx.globalAlpha = 1 - progress;
                drawSpiral();
                ctx.globalAlpha = progress;
                drawDiagonalSerpent(centerY() - sepActual / 2, colors[1], colors[1], 1);
                drawDiagonalSerpent(centerY() + sepActual / 2, colors[2], colors[2], -1);
            } else {
                ctx.globalAlpha = 1;
                drawDiagonalSerpent(centerY() - sepActual / 2, colors[1], colors[1], 1);
                drawDiagonalSerpent(centerY() + sepActual / 2, colors[2], colors[2], -1);
            }
            
            ctx.restore();
        }
        
        function getDynamicColor() {
            const r = Math.min(255, 255 - Math.floor(puntaje / 3));
            const g = Math.min(255, 255 - Math.floor(puntaje / 2));
            const b = 255;
            return `rgb(${r}, ${g}, ${b})`;
        }

        // --- PAREDES ONDULANTES ---
        function updateAndDrawWalls() {
            ctx.save();
            const wallColor = getDynamicColor();
            ctx.fillStyle = wallColor;
            ctx.shadowColor = wallColor;
            ctx.shadowBlur = 15;
            const amplitude = canvas.height * 0.1;
            const frequency = 2;
            const baseHeight = canvas.height * 0.15;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            for (let x = 0; x <= canvas.width; x += 10) {
                ctx.lineTo(x, baseHeight + Math.sin(x * 0.01 + gameTime * frequency) * amplitude);
            }
            ctx.lineTo(canvas.width, 0);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            for (let x = 0; x <= canvas.width; x += 10) {
                ctx.lineTo(x, canvas.height - (baseHeight + Math.sin(x * 0.01 + gameTime * frequency) * amplitude));
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function getWallPositions(x) {
            const amplitude = canvas.height * 0.1;
            const frequency = 2;
            const baseHeight = canvas.height * 0.15;
            const wave = Math.sin(x * 0.01 + gameTime * frequency) * amplitude;
            return { topWallY: baseHeight + wave, bottomWallY: canvas.height - (baseHeight + wave) };
        }

        // --- OBSTÁCULOS (NUEVOS PATRONES) ---
        let nextSpawnTime = 1;
        const PATTERNS = { OBS1:1, OBS2:2, OBS3:3, OBS4:4, OBS5:5, OBS6:6 };

        function scheduleNextObstacle() {
            const difficulty = getDifficultyMultiplier();
            const spawnInterval = obstaculoBaseInterval / difficulty;
            nextSpawnTime = gameTime + spawnInterval * (0.9 + Math.random() * 0.3);
            const choice = Math.floor(Math.random() * 6) + 1;
            // If in tutorial and this is the first real spawn, schedule and then show obstacle hint overlay
            if (tutorialMode && !tutorialFirstObstacleShown) {
                tutorialFirstObstacleShown = true;
                // spawn the obstacle so it appears, but pause the game progression so it freezes on screen
                spawnPattern(choice);
                // Pause progression and show obstacle hint overlay
                tutorialPaused = true;
                tutorialStage = 2;
                showTutorialOverlay('Maneje la abertura de las serpientes para esquivar los obstáculos', true);
            } else {
                spawnPattern(choice);
            }
        }

        // --- PATRONES DE OBSTÁCULOS DEL EDITOR ---
        function spawnPattern(type) {
            const cx = canvas.width + obstaculoBaseSize * 2; // posición inicial fuera de la pantalla
            const cy = centerY();
            const s = obstaculoBaseSize;
            const gap = s * 2.2;

            switch(type) {
                case 1: // obs1
                    obstaculos.push({x:cx, y:cy, size:s*0.7});
                    break;
                case 2: // obs2
                    obstaculos.push({x:cx, y:cy, size:s*1.6});
                    break;
                case 3: // obs3
                    obstaculos.push({x:cx, y:cy-1.5*gap, size:s*0.7});
                    obstaculos.push({x:cx, y:cy+1.5*gap, size:s*0.7});
                    break;
                case 4: // obs4
                    obstaculos.push({x:cx-2*gap, y:cy-1.4*gap, size:s*0.7});
                    obstaculos.push({x:cx-2*gap, y:cy+1.4*gap, size:s*0.7});
                    obstaculos.push({x:cx, y:cy, size:s*0.7});
                    obstaculos.push({x:cx+2*gap, y:cy+1.4*gap, size:s*0.7});
                    obstaculos.push({x:cx+2*gap, y:cy-1.4*gap, size:s*0.7});
                    break;
                case 5: // obs5
                    obstaculos.push({x:cx, y:cy-1.1*gap, size:s*0.7});
                    obstaculos.push({x:cx-2*gap, y:cy, size:s*0.7});
                    obstaculos.push({x:cx, y:cy+1.1*gap, size:s*0.7});
                    obstaculos.push({x:cx+2*gap, y:cy, size:s*0.7});
                    break;
                case 6: // obs6
                    obstaculos.push({x:cx-3.8*gap, y:cy, size:s*0.7});
                    obstaculos.push({x:cx-2*gap, y:cy, size:s*1.6});
                    obstaculos.push({x:cx-3*gap, y:cy, size:s*1.0});
                    obstaculos.push({x:cx, y:cy-1.5*gap, size:s*0.7});
                    obstaculos.push({x:cx, y:cy+1.5*gap, size:s*0.7});
                    obstaculos.push({x:cx+3*gap, y:cy, size:s*1.0});
                    obstaculos.push({x:cx+2*gap, y:cy, size:s*1.6});
                    obstaculos.push({x:cx+3.8*gap, y:cy, size:s*0.7});
                    break;
            }
        }


        function updateObstaculos(deltaTime) {
            const speed = obstaculoBaseSpeed * getDifficultyMultiplier();
            obstaculos.forEach(obs => { obs.x -= speed * deltaTime; });
            obstaculos = obstaculos.filter(obs => obs.x + obs.size / 2 > 0);
        }

        function drawObstaculos() {
            ctx.save();
            const obsColor = getDynamicColor();
            for (const obs of obstaculos) {
                ctx.beginPath();
                ctx.arc(obs.x, obs.y, obs.size / 2, 0, Math.PI * 2);
                ctx.fillStyle = obsColor;
                ctx.shadowColor = obsColor;
                ctx.shadowBlur = 16;
                ctx.fill();
            }
            ctx.restore();
        }

        // --- COLISIÓN ---
        function checkColision() {
            const y1 = centerY() - sepActual / 2;
            const y2 = centerY() + sepActual / 2;
            for(let x = startX; x <= endX; x += 20) {
                const { topWallY, bottomWallY } = getWallPositions(x);
                if ((y1 - serpienteWidth / 2) <= topWallY || (y2 + serpienteWidth / 2) >= bottomWallY) {
                    return true;
                }
            }
            const p1_top = { x: startX, y: y1 };
            const p2_top = { x: endX, y: y1 - currentDiagonalOffset * 1 };
            const p1_bottom = { x: startX, y: y2 };
            const p2_bottom = { x: endX, y: y2 - currentDiagonalOffset * -1 };

            for (const obs of obstaculos) {
                if (isThickLineCollidingWithCircle(obs, p1_top, p2_top, serpienteWidth)) return true;
                if (sepActual > separationMin + 5 && isThickLineCollidingWithCircle(obs, p1_bottom, p2_bottom, serpienteWidth)) return true;
            }
            return false;
        }

        function isThickLineCollidingWithCircle(circle, p1, p2, thickness) {
            const circleR = circle.size / 2;
            const lineR = thickness / 2;
            const lineVec = { x: p2.x - p1.x, y: p2.y - p1.y };
            const p1ToCircle = { x: circle.x - p1.x, y: circle.y - p1.y };
            const lineLenSq = lineVec.x * lineVec.x + lineVec.y * lineVec.y;
            let t = (p1ToCircle.x * lineVec.x + p1ToCircle.y * lineVec.y) / lineLenSq;
            t = Math.max(0, Math.min(1, t));
            const closestPoint = { x: p1.x + t * lineVec.x, y: p1.y + t * lineVec.y };
            const distSq = (circle.x - closestPoint.x)**2 + (circle.y - closestPoint.y)**2;
            return distSq < (circleR + lineR)**2;
        }

        // --- Tutorial helpers ---
        function showTutorialOverlay(text, withDemo) {
            const backdrop = document.getElementById('tutorial-backdrop');
            const title = document.getElementById('tutorial-title');
            const demoCanvas = document.getElementById('tutorial-demo-canvas');
            title.textContent = text;
            backdrop.style.display = 'flex';
            if (withDemo) {
                demoCanvas.style.display = 'block';
                startDemoAnimation(demoCanvas, text);
            } else {
                demoCanvas.style.display = 'none';
            }
            // One-time handlers: click on backdrop or CTA will hide overlay and, if it's the obstacle hint,
            // resume the tutorial gameplay.
            const cta = document.getElementById('tutorial-cta');
            function onCloseTutorialOverlay(e) {
                e && e.stopPropagation && e.stopPropagation();
                hideTutorialOverlay();
                // If we were paused for the obstacle hint, resume
                if (tutorialMode && tutorialStage === 2) {
                    tutorialPaused = false;
                    tutorialStage = 3;
                }
                backdrop.removeEventListener('click', onCloseTutorialOverlay);
                cta.removeEventListener('click', onCloseTutorialOverlay);
            }
            backdrop.addEventListener('click', onCloseTutorialOverlay);
            cta.addEventListener('click', onCloseTutorialOverlay);
        }

        function hideTutorialOverlay() {
            const backdrop = document.getElementById('tutorial-backdrop');
            const demoCanvas = document.getElementById('tutorial-demo-canvas');
            backdrop.style.display = 'none';
            stopDemoAnimation();
        }

        // Improved demo animation: draw simplified game-like serpientes and moving obstacles
        let demoReq = null;
        let demoState = { t:0, mode:'intro' };
        function startDemoAnimation(canvasEl, modeText) {
            const ctxd = canvasEl.getContext('2d');
            // demo-local state that mirrors main game variables so the demo looks identical
            let demoGameTime = 0;
            let demoLast = performance.now();
            let demoSepActual = separationMin;
            let demoSepObjetivo = separationMin;
            let demoIsClosing = false;
            let demoTargetDiagonalOffset = 0;
            let demoCurrentDiagonalOffset = 0;
            demoState.t = 0;
            demoState.mode = modeText.toLowerCase().includes('abrir') ? 'open' : 'obstacle';

            // helper: update demo serpientes using same math as updateSerpientes()
            function updateDemoSerpientes(dt) {
                const maxOpeningSpeed = 500 * dt;
                const maxClosingSpeed = 700 * dt;
                if (demoIsClosing) {
                    demoSepObjetivo -= maxClosingSpeed;
                } else {
                    demoSepObjetivo += maxOpeningSpeed;
                }
                demoSepObjetivo = Math.max(separationMin, demoSepObjetivo);
                const lerpFactor = 8;
                const previousSep = demoSepActual;
                demoSepActual += (demoSepObjetivo - demoSepActual) * lerpFactor * dt;
                const movementSpeed = demoSepActual - previousSep;
                demoTargetDiagonalOffset = movementSpeed * 2.5;
                demoTargetDiagonalOffset = Math.max(-20, Math.min(demoTargetDiagonalOffset, 20));
                const smoothingFactor = 12 * dt;
                demoCurrentDiagonalOffset += (demoTargetDiagonalOffset - demoCurrentDiagonalOffset) * smoothingFactor;
            }

            function drawDemoSerpientes(w, h) {
                const demoCtx = ctxd;
                demoCtx.save();
                // compute demo start/end using serpienteLength scaled to demo box
                const demoStartX = Math.floor(w * 0.12);
                const demoEndX = demoStartX + Math.max(20, Math.round(serpienteLength));

                const drawDiagonalSerpent = (y, color, shadowColor, direction) => {
                    demoCtx.beginPath();
                    const startPointY = y;
                    const endPointY = y - demoCurrentDiagonalOffset * direction;
                    demoCtx.moveTo(demoStartX, startPointY);
                    demoCtx.lineTo(demoEndX, endPointY);
                    demoCtx.strokeStyle = color;
                    demoCtx.lineWidth = serpienteWidth;
                    demoCtx.shadowColor = shadowColor;
                    demoCtx.shadowBlur = 12;
                    demoCtx.lineCap = 'round';
                    demoCtx.stroke();
                };

                const drawSpiral = () => {
                    const rollTime = demoGameTime * 15;
                    const rollSin = Math.sin(rollTime);
                    const spiralFreq = 0.08;
                    const spiralAmp = serpienteWidth * 0.35;
                    const frontWidth = serpienteWidth * 0.7;
                    const backWidth = serpienteWidth * 0.55;
                    const drawSpiralWave = (phase, color, width) => {
                        demoCtx.beginPath();
                        demoCtx.moveTo(demoStartX, h/2 + Math.sin(demoStartX * spiralFreq + rollTime + phase) * spiralAmp);
                        for (let x = demoStartX + 4; x <= demoEndX; x += 4) {
                            demoCtx.lineTo(x, h/2 + Math.sin(x * spiralFreq + rollTime + phase) * spiralAmp);
                        }
                        demoCtx.strokeStyle = color;
                        demoCtx.lineWidth = width;
                        demoCtx.shadowColor = color;
                        demoCtx.shadowBlur = 10;
                        demoCtx.lineCap = 'round';
                        demoCtx.stroke();
                    };
                    const colors = getSnakeColors();
                    if (rollSin > 0) {
                        drawSpiralWave(Math.PI, colors[2], backWidth);
                        drawSpiralWave(0, colors[1], frontWidth);
                    } else {
                        drawSpiralWave(0, colors[1], backWidth);
                        drawSpiralWave(Math.PI, colors[2], frontWidth);
                    }
                };

                const transitionStart = separationMin;
                const transitionEnd = separationMin + 40;

                const colors = getSnakeColors();
            if (demoSepActual <= transitionStart) {
                    drawSpiral();
                } else if (demoSepActual > transitionStart && demoSepActual < transitionEnd) {
                    const progress = (demoSepActual - transitionStart) / (transitionEnd - transitionStart);
                    demoCtx.globalAlpha = 1 - progress;
                    drawSpiral();
                    demoCtx.globalAlpha = progress;
                    drawDiagonalSerpent(h/2 - demoSepActual / 2, colors[1], colors[1], 1);
                    drawDiagonalSerpent(h/2 + demoSepActual / 2, colors[2], colors[2], -1);
                } else {
                    demoCtx.globalAlpha = 1;
                    drawDiagonalSerpent(h/2 - demoSepActual / 2, colors[1], colors[1], 1);
                    drawDiagonalSerpent(h/2 + demoSepActual / 2, colors[2], colors[2], -1);
                }

                demoCtx.restore();
            }

            // prepare demo obstacles sequence for obstacle mode
            const demoObstacles = [];
            const demoSpacing = 180; // px between obstacles
            const demoSpeed = 220; // px/s
            function initDemoObstacles(cw) {
                demoObstacles.length = 0;
                // If intro/open mode: don't spawn visible obstacles; just keep demo serpientes separated
                if (demoState.mode === 'open') {
                    return;
                }
                // obstacle mode: create an explicit alternating pattern (1,0,1,0...) so obstacles appear every other slot
                const slots = 10; // total slots positions along the x-axis
                const baseX = cw + 60;
                for (let i = 0; i < slots; i++) {
                    // only create actual obstacles for even indices to keep 1-0-1-0 pattern
                    if (i % 2 === 0) {
                        const startPos = baseX + i * demoSpacing;
                        demoObstacles.push({ x: startPos, size: Math.max(10, Math.round(obstaculoBaseSize * 0.35)) });
                    } else {
                        // keep placeholders (null) to preserve spacing logic if needed
                    }
                }
            }

            // demo loop
            function step() {
                const now = performance.now();
                const dt = Math.min(0.05, (now - demoLast) / 1000);
                demoLast = now;
                demoGameTime += dt;
                demoState.t += dt;

                const dpr = window.devicePixelRatio || 1;
                const cw = canvasEl.clientWidth;
                const ch = canvasEl.clientHeight;
                canvasEl.width = Math.max(1, Math.floor(cw * dpr));
                canvasEl.height = Math.max(1, Math.floor(ch * dpr));
                ctxd.setTransform(dpr,0,0,dpr,0,0);
                ctxd.clearRect(0,0,cw,ch);
                ctxd.fillStyle = '#0f0f0f';
                ctxd.fillRect(0,0,cw,ch);

                // Initialize obstacles array if empty (for obstacle mode)
                if (demoObstacles.length === 0) initDemoObstacles(cw);

                // Move obstacles (only relevant in obstacle mode)
                if (demoState.mode === 'obstacle') {
                    for (const obs of demoObstacles) {
                        obs.x -= demoSpeed * dt;
                    }
                }
                // recycle obstacles that moved off-left, preserving alternating spacing/order
                if (demoObstacles.length > 0) {
                    for (let i = 0; i < demoObstacles.length; i++) {
                        if (demoObstacles[i].x < -80) {
                            // find current maxX and place this obstacle after it keeping demoSpacing
                            const maxX = Math.max(...demoObstacles.map(o => o.x));
                            demoObstacles[i].x = maxX + demoSpacing;
                        }
                    }
                }

                // Determine proximity to the next obstacle relative to demo center area
                const demoCenterX = cw * 0.55; // position where player is visually
                // find the first obstacle to the right of center
                let nextObs = null;
                let minDist = Infinity;
                for (const obs of demoObstacles) {
                    const dist = obs.x - demoCenterX;
                    if (dist >= -200 && dist < minDist) { minDist = dist; nextObs = obs; }
                }

                // If in obstacle mode, control open/close based on proximity to next obstacle
                if (demoState.mode === 'obstacle' && nextObs) {
                    const closeThreshold = 110; // px before center to start closing
                    const reopenThreshold = -30; // px after passing center to reopen
                    if (minDist <= closeThreshold && minDist >= reopenThreshold) {
                        demoIsClosing = true;
                    } else if (minDist < reopenThreshold) {
                        demoIsClosing = false;
                    } else {
                        // gaps between obstacles: keep opened state
                        demoIsClosing = false;
                    }
                    // set desired sep depending on obstacle size — increase multiplier so demo opens more
                    const desiredOpen = separationMin + (nextObs.size * 3.2); // larger gap relative to obstacle
                    // when closing, go to separationMin (full close) to show the closing animation
                    demoSepObjetivo = demoIsClosing ? separationMin : desiredOpen;
                } else {
                    // intro/open mode: no obstacles and keep snake more separated but ensure full close animation
                    if (demoState.mode === 'open') {
                        // force a larger opening to visualize separation (no obstacles present)
                        demoSepObjetivo = separationMin + 48; // even more open for clarity
                        // create a clear close cycle so that when demoIsClosing is true it reaches full close
                        demoIsClosing = Math.sin(demoState.t * 3.5) > 0.6;
                        if (demoIsClosing) {
                            // when closing, ensure the objetivo goes to separationMin so lerp will reach it
                            demoSepObjetivo = separationMin;
                        }
                    } else {
                        demoIsClosing = Math.sin(demoState.t * 3.0) > 0.3;
                        demoSepObjetivo = demoIsClosing ? separationMin : separationMin + 18;
                    }
                }

                // Update serpientes after setting objetivo
                updateDemoSerpientes(dt);

                // draw demo serpientes using same logic
                drawDemoSerpientes(cw, ch);

                // draw obstacles
                for (const obs of demoObstacles) {
                    if (obs.x > -80 && obs.x < cw + 80) {
                        ctxd.beginPath(); ctxd.fillStyle = '#ffffff'; ctxd.shadowColor = '#ffffff'; ctxd.shadowBlur = 8;
                        ctxd.arc(obs.x, ch/2, obs.size, 0, Math.PI*2); ctxd.fill();
                    }
                }

                demoReq = requestAnimationFrame(step);
            }

            stopDemoAnimation();
            demoLast = performance.now();
            demoReq = requestAnimationFrame(step);
        }
        function stopDemoAnimation() { if (demoReq) { cancelAnimationFrame(demoReq); demoReq = null; } }

        // --- LOOP PRINCIPAL (tutorial-aware) ---
        function gameLoop(currentTime) {
            if (gameOver) return;

            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!tutorialPaused && gameHasStarted) {
                gameTime += deltaTime;
                updateSerpientes(deltaTime);
                updateObstaculos(deltaTime);
                if (gameTime > nextSpawnTime) {
                    scheduleNextObstacle();
                }
                puntaje += deltaTime * 10;
                puntajeDiv.textContent = "Puntaje: " + Math.floor(puntaje);
            } else if (gameHasStarted) {
                // still draw serpientes without advancing
                updateSerpientes(0);
            }

            updateAndDrawWalls();
            drawSerpientes();
            drawObstaculos();

            if (gameHasStarted && checkColision()) {
                gameOver = true;
                document.body.style.backgroundColor = '#500';
                setTimeout(() => {
                    const finalScore = Math.floor(puntaje);
                    const tutorialParam = tutorialMode ? '&tutorial=1' : '';
                    if (modo === "ranked") {
                        const user = localStorage.getItem('usuario_looper') || '';
                        guardarRanking(user, finalScore)
                            .then(resp => {
                                // resp puede ser "nuevo", "no", "error"
                                window.location.href = `LOOPER_TERMINAR.html?puntaje=${finalScore}&usuario=${encodeURIComponent(user)}&nuevo_record=${resp === "nuevo" ? 1 : 0}${tutorialParam}`;
                            })
                            .catch(err => {
                                console.error("Error guardando ranking:", err);
                                window.location.href = `LOOPER_TERMINAR.html?puntaje=${finalScore}&usuario=${encodeURIComponent(user)}&nuevo_record=0${tutorialParam}`;
                            });
                    } else {
                        window.location.href = `LOOPER_TERMINAR.html?puntaje=${finalScore}${tutorialParam}`;
                    }
                }, 600);
            }

            requestAnimationFrame(gameLoop);
        }

        // start main loop and initialize tutorial UI if needed
        requestAnimationFrame(gameLoop);

        // Initialize tutorial overlay after functions exist
        (function initTutorial() {
            if (!tutorialMode) return;
            tutorialPaused = true;
            tutorialStage = 0;
            // wait a tick to ensure DOM elements exist
            setTimeout(() => {
                showTutorialOverlay('Presione Click izq. o Espacio para abrir y comenzar el juego', true);
                // CTA: listen for click on backdrop to confirm the tutorial intro.
                // IMPORTANT: do not start game progression automatically here — keep the game paused
                // after the intro overlay so the user must explicitly press/click inside the game area
                // (or press Space) to begin (same behavior as normal game start).
                const backdrop = document.getElementById('tutorial-backdrop');
                const cta = document.getElementById('tutorial-cta');
                function onConfirmIntro() {
                    hideTutorialOverlay();
                    // Keep progression paused but mark intro as confirmed (stage = 1).
                    // The next user interaction inside the game area will call startGameOnce()
                    // which will unpause and start the game.
                    tutorialPaused = true;
                    tutorialStage = 1; // intro confirmed, awaiting user's real input to start
                    backdrop.removeEventListener('click', onConfirmIntro);
                    cta.removeEventListener('click', onConfirmIntro);
                }
                backdrop.addEventListener('click', onConfirmIntro);
                cta.addEventListener('click', onConfirmIntro);
            }, 200);
        })();
    </script>

    <!-- Tutorial overlay markup -->
    <div id="tutorial-backdrop" class="tutorial-overlay-backdrop">
        <div class="tutorial-box">
            <h3 id="tutorial-title">Tutorial</h3>
            <div class="tutorial-demo">
                <canvas id="tutorial-demo-canvas" style="width:100%;height:100%;display:block;"></canvas>
            </div>
            <div id="tutorial-cta" class="tutorial-cta">Continuar</div>
        </div>
    </div>

</body>
</html>
        }